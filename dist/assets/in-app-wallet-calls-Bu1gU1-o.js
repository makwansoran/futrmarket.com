import{aY as m,O as p,P as h,aS as w,y as f,aZ as T}from"./index-Cn3kq7oy.js";import{s as b}from"./send-transaction-D6lpxEtY.js";import{r as g}from"./random-NeYOSU-c.js";import"./to-serializable-transaction-CINlwqk-.js";async function y(o){const s=await b(o);return m(s)}async function H(o){const{account:s,transactions:c}=o;if(!s)throw new Error("not connected");if(c.length===0)throw new Error("No transactions to send");const n=c[0];if(!n)throw new Error("No transactions to send");if(s.sendBatchTransaction){const a=await Promise.all(c.map(async t=>{const[r,l,e,d]=await Promise.all([p(t),h(t.to),h(t.accessList),h(t.value)]);return{accessList:e,chainId:t.chain.id,data:r,to:l,value:d}}));return{...await s.sendBatchTransaction(a),chain:n.chain,client:n.client}}throw new Error("Account doesn't implement sendBatchTransaction")}const u=new w(1e3);async function v(o){const{account:s,calls:c}=o,n=c.map(t=>({...t,chain:o.chain})),a=[],i=g(65);if(u.set(i,a),s.sendBatchTransaction){const t=await H({account:s,transactions:n});a.push(t.transactionHash),u.set(i,a)}else for(const t of n){const r=await y({account:s,transaction:t});a.push(r.transactionHash),u.set(i,a)}return i}async function x(o){const{chain:s,client:c,id:n}=o,a=u.get(n);if(!a)throw new Error("Failed to get calls status, unknown bundle id");const i=f({chain:s,client:c});let t="success";const r=await Promise.all(a.map(l=>T(i,{hash:l}).then(e=>({blockHash:e.blockHash,blockNumber:e.blockNumber,gasUsed:e.gasUsed,logs:e.logs.map(d=>({address:d.address,data:d.data,topics:d.topics})),status:e.status,transactionHash:e.transactionHash})).catch(()=>(t="pending",null))));return{atomic:!1,chainId:s.id,id:n,receipts:r.filter(l=>l!==null),status:t,statusCode:200,version:"2.0.0"}}export{x as inAppWalletGetCallsStatus,v as inAppWalletSendCalls};
