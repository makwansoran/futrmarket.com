import{e as p}from"./utils-K5Uh5N8m.js";import{concatHex as v}from"./concat-hex-D70TxF1Q.js";import{readContract as x}from"./read-contract-D2Vq_7_K.js";import{a_ as f,a$ as D,T as c,b0 as m,b1 as M,b2 as I,b3 as C,b4 as V,z as g,H as h,O as l}from"./index-Cn3kq7oy.js";import{p as w}from"./index-Cij_JTZo.js";import"./to-serializable-transaction-CINlwqk-.js";import"./bundler-aFvEyNsc.js";import"./addresses-Cbjra2SQ.js";import"./send-eip712-transaction-CDIeKzxW.js";import"./eth_sendRawTransaction-DPdnXbFR.js";import"./random-NeYOSU-c.js";import"./send-transaction-D6lpxEtY.js";const _="0x1626ba7e",H=[{name:"hash",type:"bytes32"},{name:"signature",type:"bytes"}],P=[{type:"bytes4"}];async function $(t){return x({contract:t.contract,method:[_,H,P],params:[t.hash,t.signature]})}const O="0x6492649264926492649264926492649264926492649264926492649264926492";function A({address:t,data:r,signature:e}){return v([p([{type:"address"},{type:"bytes"},{type:"bytes"}],[t,r,e]),O])}const F="0x1626ba7e";async function b({hash:t,signature:r,contract:e}){try{return await $({contract:e,hash:t,signature:r})===F}catch(n){return console.error("Error verifying EIP-1271 signature",n),!1}}const U=`Ethereum Signed Message:
`;function L(t,r){const e=typeof t=="string"?f(t):t.raw instanceof Uint8Array?t.raw:D(t.raw),n=f(`${U}${e.length}`);return c(m(n,e),r)}function B(t){const{domain:r={},message:e,primaryType:n}=t,a={EIP712Domain:M(r),...t.types};I({domain:r,message:e,primaryType:n,types:a});const s=["0x1901"];if(r&&s.push(C({domain:r,types:a})),n!=="EIP712Domain"){const i=(()=>{const o=T({data:e,primaryType:n,types:a});return c(o)})();s.push(i)}return c(m(...s.map(i=>V(i))))}function T({data:t,primaryType:r,types:e}){const n=[{type:"bytes32"}],a=[N({primaryType:r,types:e})];if(!e[r])throw new Error("Invalid types");for(const s of e[r]){const[i,o]=E({name:s.name,type:s.type,types:e,value:t[s.name]});n.push(i),a.push(o)}return p(n,a)}function N({primaryType:t,types:r}){const e=g(k({primaryType:t,types:r}));return c(e)}function k({primaryType:t,types:r}){let e="";const n=S({primaryType:t,types:r});n.delete(t);const a=[t,...Array.from(n).sort()];for(const s of a){if(!r[s])throw new Error("Invalid types");e+=`${s}(${r[s].map(({name:i,type:o})=>`${o} ${i}`).join(",")})`}return e}function S({primaryType:t,types:r},e=new Set){const a=t.match(/^\w*/u)?.[0];if(e.has(a)||r[a]===void 0)return e;e.add(a);for(const s of r[a])S({primaryType:s.type,types:r},e);return e}function E({types:t,name:r,type:e,value:n}){if(t[e]!==void 0)return[{type:"bytes32"},c(T({data:n,primaryType:e,types:t}))];if(e==="bytes")return n=`0x${(n.length%2?"0":"")+n.slice(2)}`,[{type:"bytes32"},c(n)];if(e==="string")return[{type:"bytes32"},c(g(n))];if(e.lastIndexOf("]")===e.length-1){const a=e.slice(0,e.lastIndexOf("[")),s=n.map(i=>E({name:r,type:a,types:t,value:i}));return[{type:"bytes32"},c(p(s.map(([i])=>i),s.map(([,i])=>i)))]}return[{type:e},n]}async function te({accountContract:t,factoryContract:r,options:e,message:n}){const a=L(n);let s;const i=p([{type:"bytes32"}],[a]);if(s=await e.personalAccount.signTypedData({domain:{chainId:e.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:{message:i},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}}),await h(t)){if(await b({contract:t,hash:a,signature:s}))return s;throw new Error("Failed to verify signature")}else{const u=w({accountSalt:e.overrides?.accountSalt,adminAddress:e.personalAccount.address,createAccountOverride:e.overrides?.createAccount,factoryContract:r});if(!u)throw new Error("Create account override not provided");const d=await l(u);return A({address:r.address,data:d,signature:s})}}async function re({accountContract:t,factoryContract:r,options:e,typedData:n}){if(n.domain?.verifyingContract?.toLowerCase()===t.address?.toLowerCase())return e.personalAccount.signTypedData(n);const s=B(n);let i;const o=p([{type:"bytes32"}],[s]);if(i=await e.personalAccount.signTypedData({domain:{chainId:e.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:{message:o},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}}),await h(t)){if(await b({contract:t,hash:s,signature:i}))return i;throw new Error("Failed to verify signature")}else{const d=w({accountSalt:e.overrides?.accountSalt,adminAddress:e.personalAccount.address,createAccountOverride:e.overrides?.createAccount,factoryContract:r});if(!d)throw new Error("Create account override not provided");const y=await l(d);return A({address:r.address,data:y,signature:i})}}export{te as smartAccountSignMessage,re as smartAccountSignTypedData};
